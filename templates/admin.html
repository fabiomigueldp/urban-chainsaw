<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trading Signal Processor - Admin Dashboard</title>
    
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        :root {
            --bs-primary: #0d6efd;
            --bs-success: #198754;
            --bs-warning: #ffc107;
            --bs-danger: #dc3545;
            --bs-info: #0dcaf0;
            --bs-dark: #212529;
            --bs-light: #f8f9fa;
        }
        
        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .navbar-brand {
            font-weight: bold;
            font-size: 1.5rem;
        }
        
        .status-card {
            transition: all 0.3s ease;
            border: none;
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
        }
        
        .status-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: bold;
        }
        
        .metric-label {
            font-size: 0.875rem;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        
        .status-online {
            background-color: var(--bs-success);
            animation: pulse 2s infinite;
        }
        
        .status-offline {
            background-color: var(--bs-danger);
        }
        
        .status-paused {
            background-color: var(--bs-warning);
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin: 20px 0;
        }
        
        .audit-table {
            font-size: 0.875rem;
        }
        
        .badge-status {
            font-size: 0.75rem;
        }
        
        .refresh-btn {
            transition: transform 0.3s ease;
        }
        
        .refresh-btn:hover {
            transform: rotate(180deg);
        }
        
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1050;
            min-width: 200px;
        }
        
        .filter-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
            margin-bottom: 20px;
        }
        
        .section-header {
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .action-buttons .btn {
            margin: 0 5px 10px 0;
        }
        
        .loading-spinner {
            display: none;
        }
        
        .table-responsive {
            max-height: 500px;
        }
        
        .progress-container {
            margin: 10px 0;
        }
        
        .alert-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 1040;
            max-width: 400px;
        }
        
        .sell-all-ticker {
            margin: 2px;
            padding: 4px 8px;
            background: #e9ecef;
            border-radius: 4px;
            font-size: 0.875rem;
            display: inline-block;
        }
        
        .clickable-ticker {
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        
        .clickable-ticker:hover {
            background-color: #007bff;
            color: white;
            border-color: #0056b3;
            transform: translateY(-1px);
        }
        
        .top-n-ticker {
            margin: 2px;
            padding: 4px 8px;
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            border-radius: 4px;
            font-size: 0.875rem;
            display: inline-block;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }
        
        .top-n-ticker:hover {
            background: #b8daff;
            border-color: #6ba6cd;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .top-n-ticker:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        /* Database Management Discrete Controls */
        .database-actions {
            border-left: 1px solid #dee2e6;
            padding-left: 12px;
        }
        
        .database-actions .btn {
            width: 32px;
            height: 32px;
            padding: 0;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .database-actions .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .database-actions .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .database-actions .btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }
        
        #csvFileName {
            font-size: 0.75rem;
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
</head>
<body>
    <!-- Connection Status Alert -->
    <div id="connectionStatus" class="connection-status">
        <div class="alert alert-info alert-dismissible" role="alert">
            <i class="bi bi-wifi"></i> Connecting to server...
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        </div>
    </div>
    
    <!-- Alert Container -->
    <div id="alertContainer" class="alert-container"></div>
    
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <i class="bi bi-graph-up-arrow"></i>
                Trading Signal Processor
            </a>
            <div class="navbar-nav ms-auto">
                <span class="navbar-text">
                    <span id="connectionIndicator" class="status-indicator status-offline"></span>
                    <span id="connectionText">Disconnected</span>
                </span>
            </div>
        </div>
    </nav>
    
    <!-- Main Content -->
    <div class="container-fluid mt-4">
        <!-- Status Cards -->
        <div class="row mb-4">
            <div class="col-md-3">
                <div class="card status-card text-center">
                    <div class="card-body">
                        <div class="metric-value text-primary" id="signalsReceived">-</div>
                        <div class="metric-label">Signals Received</div>
                        <small class="text-muted">Total since start</small>
                    </div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card status-card text-center">
                    <div class="card-body">
                        <div class="metric-value text-success" id="signalsApproved">-</div>
                        <div class="metric-label">Signals Approved</div>
                        <small class="text-muted">Passed Top-N filter</small>
                    </div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card status-card text-center">
                    <div class="card-body">
                        <div class="metric-value text-warning" id="signalsRejected">-</div>
                        <div class="metric-label">Signals Rejected</div>
                        <small class="text-muted">Did not pass filter</small>
                    </div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card status-card text-center">
                    <div class="card-body">
                        <div class="metric-value text-info" id="signalsForwarded">-</div>
                        <div class="metric-label">Signals Forwarded</div>
                        <small class="text-muted">Successfully sent</small>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Queue Status and System Info -->
        <div class="row mb-4">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-queue"></i> Queue Status
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="row text-center">
                            <div class="col-6">
                                <div class="metric-value text-primary" id="processingQueueSize">-</div>
                                <div class="metric-label">Processing Queue</div>
                            </div>
                            <div class="col-6">
                                <div class="metric-value text-warning" id="approvedQueueSize">-</div>
                                <div class="metric-label">Forwarding Queue</div>
                            </div>
                        </div>
                        <div class="progress-container">
                            <div class="d-flex justify-content-between small">
                                <span>Processing Workers:</span>
                                <span id="processingWorkersActive">-</span>
                            </div>
                            <div class="progress mb-2">
                                <div id="processingWorkerProgress" class="progress-bar bg-info" role="progressbar" style="width: 0%"></div>
                            </div>
                            <div class="d-flex justify-content-between small">
                                <span>Forwarding Workers:</span>
                                <span id="forwardingWorkersActive">-</span>
                            </div>
                            <div class="progress">
                                <div id="forwardingWorkerProgress" class="progress-bar bg-warning" role="progressbar" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-info-circle"></i> System
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-6">
                                <strong>Engine Status:</strong><br>
                                <span id="engineStatus" class="badge badge-status">-</span>
                            </div>
                            <div class="col-6">
                                <strong>Rate Limiter:</strong><br>
                                <span id="rateLimiterStatus" class="badge badge-status">-</span>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-6">
                                <strong>Top-N Tickers:</strong><br>
                                <span id="tickerCount">-</span>
                            </div>
                            <div class="col-6">
                                <strong>Uptime:</strong><br>
                                <span id="uptime">-</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Charts Section -->
        <div class="row mb-4">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-bar-chart"></i> Signals per Hour
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="signalsChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-pie-chart"></i> Approval Rate
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="chart-container">
                            <canvas id="approvalChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Control Actions and Reprocessing -->
        <div class="row mb-4">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-gear"></i> System Controls
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="action-buttons">
                            <button id="pauseEngineBtn" class="btn btn-warning btn-sm">
                                <i class="bi bi-pause"></i> Pause Engine
                            </button>
                            <button id="resumeEngineBtn" class="btn btn-success btn-sm">
                                <i class="bi bi-play"></i> Resume Engine
                            </button>
                            <button id="refreshEngineBtn" class="btn btn-info btn-sm">
                                <i class="bi bi-arrow-clockwise refresh-btn"></i> Refresh Tickers
                            </button>
                            <button id="resetMetricsBtn" class="btn btn-secondary btn-sm">
                                <i class="bi bi-arrow-counterclockwise"></i> Reset Metrics
                            </button>
                            <button id="pauseRateLimiterBtn" class="btn btn-warning btn-sm">
                                <i class="bi bi-pause"></i> Pause Rate Limiter
                            </button>
                            <button id="resumeRateLimiterBtn" class="btn btn-success btn-sm">
                                <i class="bi bi-play"></i> Resume Rate Limiter
                            </button>
                        </div>
                        <hr>
                        <div id="reprocessingEngineContainer">
                            <h5 class="card-title mt-4">
                                <i class="bi bi-arrow-repeat"></i> Signal Reprocessing Engine
                            </h5>
                            <!-- 1. Main Status Indicator -->
                            <div class="d-flex justify-content-between align-items-center mb-3">
                                <h6 class="mb-0">Status:</h6>
                                <span id="reprocessingEngineStatus" class="badge bg-secondary fs-6">DISABLED</span>
                            </div>

                            <!-- 2. Controles Simplificados -->
                            <div class="mb-3">
                                <label for="reprocessingModeSelect" class="form-label">Operating Mode:</label>
                                <select class="form-select" id="reprocessingModeSelect">
                                    <option value="disabled">Disabled</option>
                                    <option value="window">Time Window</option>
                                    <option value="infinite">Infinite Recovery</option>
                                </select>
                            </div>

                            <!-- 3. Time Window Field (conditionally visible) -->
                            <div id="reprocessingWindowContainer" class="mb-3" style="display: none;">
                                <label for="reprocessingWindowInput" class="form-label">Lookback Window (seconds):</label>
                                <input type="number" class="form-control" id="reprocessingWindowInput" value="300" min="1">
                                <small class="form-text text-muted">
                                    How far back to look for rejected signals (e.g., 300s = 5 minutes).
                                </small>
                            </div>

                            <!-- 4. Unified Action Button -->
                            <div class="d-grid">
                                <button id="applyReprocessingConfigBtn" class="btn btn-primary">
                                    <i class="bi bi-check-circle"></i> Apply Configuration
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="card mb-3">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-gear-fill"></i> Configuration
                        </h5>
                    </div>
                    <div class="card-body">
                        <button id="openConfigBtn" class="btn btn-primary w-100 mb-2">
                            <i class="bi bi-sliders"></i> Open Configuration Panel
                        </button>
                        <button id="setTokenBtn" class="btn btn-outline-secondary w-100">
                            <i class="bi bi-key"></i> Set Admin Token
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Top-N Tickers List and Sell All Management -->
        <div class="row mb-4">
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-star-fill"></i> Top-N Approved Tickers
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <h6 class="mb-0">Current List (<span id="topNTickerCount">0</span> tickers):</h6>
                            <button id="refreshTopNBtn" class="btn btn-outline-primary btn-sm">
                                <i class="bi bi-arrow-clockwise"></i> Refresh
                            </button>
                        </div>
                        <div id="topNTickers" class="mb-3" style="max-height: 200px; overflow-y: auto;">
                            <span class="text-muted">Loading...</span>
                        </div>
                        <small class="text-success">
                            <i class="bi bi-info-circle"></i> 
                            Click on any ticker to add it to Sell All list
                        </small>
                        <br>
                        <small class="text-muted">
                            <i class="bi bi-shield-check"></i> 
                            Only signals from these tickers will be approved and forwarded
                        </small>
                        <div id="topNLastUpdate" class="mt-2">
                            <small class="text-muted">Last Update: <span id="topNTimestamp">-</span></small>
                        </div>
                        
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <!-- Sell All Management -->
                <div class="card">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-list-check"></i> Sell All Management
                        </h5>
                    </div>
                    <div class="card-body">
                        <!-- Manual Ticker Addition -->
                        <div class="mb-3">
                            <h6>Add Ticker Manually:</h6>
                            <div class="input-group">
                                <input type="text" id="manualTickerInput" class="form-control" placeholder="Enter ticker (e.g., AAPL)" style="text-transform: uppercase;">
                                <button id="addTickerBtn" class="btn btn-outline-primary">
                                    <i class="bi bi-plus-circle"></i> Add
                                </button>
                            </div>
                        </div>
                        
                        <!-- Individual Sell Order -->
                        <div class="mb-3">
                            <h6>Individual Sell Order:</h6>
                            <div class="input-group">
                                <input type="text" id="sellIndividualInput" class="form-control" placeholder="Enter ticker to sell" style="text-transform: uppercase;">
                                <button id="sellIndividualBtn" class="btn btn-warning">
                                    <i class="bi bi-arrow-down-circle"></i> Sell
                                </button>
                            </div>
                        </div>
                        
                        <!-- Current Sell All List -->
                        <div class="mb-3">
                            <h6>Tickers in Sell All List:</h6>
                            <div id="sellAllTickers" style="max-height: 150px; overflow-y: auto;">
                                <span class="text-muted">Loading...</span>
                            </div>
                        </div>
                        
                        <!-- Cleanup Settings -->
                        <div id="sellAllCleanupContainer" class="mb-3">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <h6 class="mb-0">Cleanup Settings:</h6>
                                <span id="sellAllCleanupStatus" class="badge bg-secondary fs-6">UNKNOWN</span>
                            </div>
                            <div class="form-check form-switch mb-2">
                                <input class="form-check-input" type="checkbox" role="switch" id="cleanupEnabledSwitch">
                                <label class="form-check-label" for="cleanupEnabledSwitch">Enable Automatic Cleanup</label>
                            </div>
                            <div class="mb-2">
                                <label for="lifetimeHoursInput" class="form-label">Ticker Lifetime (hours)</label>
                                <input type="number" id="lifetimeHoursInput" class="form-control" min="1">
                                <small class="form-text text-muted">A ticker will be removed from the list after this many hours.</small>
                            </div>
                            <button id="saveCleanupConfigBtn" class="btn btn-outline-primary btn-sm w-100">
                                <i class="bi bi-save"></i> Save Cleanup Settings
                            </button>
                        </div>

                        <div class="d-grid gap-2">
                            <button id="executeSellAllBtn" class="btn btn-danger">
                                <i class="bi bi-exclamation-triangle"></i> Execute Sell All
                            </button>
                            <!-- ADD THIS NEW ROW FOR CLEAR AND REFRESH -->
                            <div class="btn-group">
                                 <button id="clearSellAllBtn" class="btn btn-outline-warning w-50">
                                    <i class="bi bi-trash"></i> Clear List Now
                                </button>
                                <button id="refreshSellAllBtn" class="btn btn-outline-secondary w-50">
                                    <i class="bi bi-arrow-clockwise"></i> Refresh List
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Audit Trail -->
        <div class="row mt-4"> <!-- Added mt-4 for spacing -->
            <!-- Orders Section -->
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-graph-up-arrow"></i> Real-Time Orders
                        </h5>
                    </div>
                    <div class="card-body">
                        <!-- Filtros -->
                        <div class="row mb-3">
                            <div class="col-md-4">
                                <select id="orderStatusFilter" class="form-select">
                                    <option value="all">All Orders</option>
                                    <option value="open">Open</option>
                                    <option value="closing">Closing</option>
                                    <option value="closed">Closed</option>
                                </select>
                            </div>
                            <div class="col-md-4">
                                <input type="text" id="tickerFilter" class="form-control" placeholder="Filter by ticker...">
                            </div>
                            <div class="col-md-4">
                                <button id="refreshOrdersBtn" class="btn btn-outline-primary">
                                    <i class="bi bi-arrow-clockwise"></i> Atualizar
                                </button>
                            </div>
                        </div>
                        
                        <!-- Real-Time Counters -->
                        <div class="row mb-3">
                            <div class="col-md-3">
                                <div class="alert alert-success mb-0">
                                    <strong id="openOrdersCount">0</strong> Open
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="alert alert-warning mb-0">
                                    <strong id="closingOrdersCount">0</strong> Closing
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="alert alert-secondary mb-0">
                                    <strong id="closedTodayCount">0</strong> Today
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="alert alert-info mb-0">
                                    <strong id="totalValueCount">$0</strong> Total
                                </div>
                            </div>
                        </div>
                        
                        <!-- Orders List -->
                        <div class="table-responsive">
                            <table class="table table-hover" id="ordersTable">
                                <thead>
                                    <tr>
                                        <th>Ticker</th>
                                        <th>Status</th>
                                        <th>Entrada</th>
                                        <th>Exit</th>
                                        <th>Duração</th>
                                        <th>Valor</th>
                                        <th>Ações</th>
                                    </tr>
                                </thead>
                                <tbody id="ordersTableBody">
                                    <tr>
                                        <td colspan="7" class="text-center">
                                            <div class="spinner-border spinner-border-sm" role="status">
                                                <span class="visually-hidden">Carregando...</span>
                                            </div>
                                            Loading orders...
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Audit Trail Section -->
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5 class="card-title mb-0">
                            <i class="bi bi-journal-text"></i> Audit Trail
                        </h5>
                    </div>
                    <div class="card-body">
                        <!-- Filters -->
                        <div class="filter-card p-3 mb-3">
                            <div class="row">
                                <div class="col-md-2">
                                    <label for="limitSelect" class="form-label">Limit:</label>
                                    <select id="limitSelect" class="form-select form-select-sm">
                                        <option value="100">100</option>
                                        <option value="500">500</option>
                                        <option value="1000">1000</option>
                                    </select>
                                </div>
                                <div class="col-md-2">
                                    <label for="statusFilter" class="form-label">Status:</label>
                                    <select id="statusFilter" class="form-select form-select-sm">
                                        <option value="">All</option>
                                        <option value="RECEIVED">Received</option>
                                        <option value="APPROVED">Approved</option>
                                        <option value="REJECTED">Rejected</option>
                                        <option value="FORWARDED_SUCCESS">Forwarded</option>
                                        <option value="FORWARDED_HTTP_ERROR">HTTP Error</option>
                                        <option value="ERROR">Error</option>
                                    </select>
                                </div>
                                <div class="col-md-2">
                                    <label for="signalTypeFilter" class="form-label">Type:</label>
                                    <select id="signalTypeFilter" class="form-select form-select-sm">
                                        <option value="">All</option>
                                        <option value="buy">Buy</option>
                                        <option value="sell">Sell</option>
                                        <option value="manual_sell">Manual Sell</option>
                                        <option value="sell_all">Sell All</option>
                                    </select>
                                </div>
                                <div class="col-md-2">
                                    <label for="tickerFilter" class="form-label">Ticker:</label>
                                    <input type="text" id="tickerFilter" class="form-control form-control-sm" placeholder="e.g., AAPL">
                                </div>
                                <div class="col-md-2">
                                    <label for="signalIdFilter" class="form-label">Signal ID:</label>
                                    <input type="text" id="signalIdFilter" class="form-control form-control-sm" placeholder="e.g., c88c6d90">
                                </div>
                                <div class="col-md-2">
                                    <label for="hourFilter" class="form-label">Last hours:</label>
                                    <select id="hourFilter" class="form-select form-select-sm">
                                        <option value="">All</option>
                                        <option value="1">1 hour</option>
                                        <option value="6">6 hours</option>
                                        <option value="24">24 hours</option>
                                        <option value="168">7 days</option>
                                    </select>
                                </div>
                            </div>
                            <div class="row mt-2">
                                <div class="col-md-3">
                                    <label class="form-label">&nbsp;</label>
                                    <div class="d-grid">
                                        <button id="applyFiltersBtn" class="btn btn-primary btn-sm">
                                            <i class="bi bi-funnel"></i> Filter
                                        </button>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <label class="form-label">&nbsp;</label>
                                    <div class="d-grid">
                                        <button id="clearFiltersBtn" class="btn btn-outline-secondary btn-sm">
                                            <i class="bi bi-x-circle"></i> Clear
                                        </button>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label text-muted small">Database Actions</label>
                                    <div class="d-flex gap-1 database-actions">
                                        <button id="downloadCsvBtn" class="btn btn-outline-info btn-sm" title="Download Full Database (CSV)">
                                            <i class="bi bi-download"></i>
                                        </button>
                                        <input type="file" class="form-control form-control-sm d-none" id="csvUploadInput" accept=".csv">
                                        <button id="selectCsvBtn" class="btn btn-outline-warning btn-sm" title="Select CSV file to upload">
                                            <i class="bi bi-folder2-open"></i>
                                        </button>
                                        <button id="uploadCsvBtn" class="btn btn-outline-success btn-sm" title="Upload selected CSV" disabled>
                                            <i class="bi bi-upload"></i>
                                        </button>
                                        <button id="clearDatabaseBtn" class="btn btn-outline-danger btn-sm" title="Clear All Database Records">
                                            <i class="bi bi-trash3"></i>
                                        </button>
                                        <small class="text-muted align-self-center ms-2" id="csvFileName"></small>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Audit Table -->
                        <div class="table-responsive">
                            <table class="table table-hover table-sm audit-table">
                                <thead class="table-dark">
                                    <tr>
                                        <th>Timestamp</th>
                                        <th>Signal ID</th>
                                        <th>Ticker</th>
                                        <th>Type</th>
                                        <th>Status</th>
                                        <th>Location</th>
                                        <th>Worker</th>
                                        <th>Details</th>
                                        <th>HTTP</th>
                                    </tr>
                                </thead>
                                <tbody id="auditTableBody">
                                    <tr>
                                        <td colspan="9" class="text-center">
                                            <div class="loading-spinner spinner-border" role="status">
                                                <span class="visually-hidden">Loading...</span>
                                            </div>
                                            Loading audit data...
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                        
                        <!-- Pagination -->
                        <div class="d-flex justify-content-between align-items-center mt-3">
                            <div class="text-muted">
                                <span id="auditResultsInfo">-</span>
                            </div>
                            <div>
                                <button id="prevPageBtn" class="btn btn-outline-secondary btn-sm me-2" disabled>
                                    <i class="bi bi-chevron-left"></i> Previous
                                </button>
                                <span id="pageInfo" class="mx-2">Page 1</span>
                                <button id="nextPageBtn" class="btn btn-outline-secondary btn-sm ms-2" disabled>
                                    Next <i class="bi bi-chevron-right"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Global variables
        let socket = null;
        let signalsChart = null;
        let approvalChart = null;
        let currentPage = 1;
        let isLoading = false;
        let isInteractingWithReprocessing = false;
        let isInteractingWithCleanup = false;
        
        // Orders management variables
        let ordersData = [];
        let ordersFilters = { status: 'all', ticker: '' };
        
        // Initialize the dashboard
        document.addEventListener('DOMContentLoaded', function() {
            initializeWebSocket();
            initializeCharts();
            loadInitialData();
            loadOrders();
            bindEventHandlers();
            
            // Auto-refresh audit trail every 30 seconds
            setInterval(loadAuditTrail, 30000);
            // Auto-refresh orders stats every 30 seconds
            setInterval(updateOrdersStats, 30000);
        });
          // WebSocket connection
        function initializeWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/admin-updates`;
            
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function(event) {
                updateConnectionStatus(true);
                console.log('WebSocket connected');
            };
            
            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };
            
            socket.onclose = function(event) {
                updateConnectionStatus(false);
                console.log('WebSocket disconnected, attempting to reconnect...');
                // Attempt to reconnect every 5 seconds
                setTimeout(initializeWebSocket, 5000);
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                updateConnectionStatus(false);
            };
        }
          // Handle WebSocket messages - UPDATED VERSION 2.0
        function handleWebSocketMessage(data) {
            try {
                console.debug('WebSocket message received:', data.type, data);
                
                switch(data.type) {
                    case 'metrics_update':
                        if (data.data) {
                            updateMetrics(data.data);
                        } else {
                            console.warn('metrics_update received with no data');
                        }
                        break;
                    case 'status_update':
                        // Handle comprehensive status update
                        if (data.data && data.data.metrics) {
                            updateMetrics(data.data.metrics);
                        }
                        if (data.data && data.data.system_info) {
                            updateSystemStatus(data.data.system_info);
                        }
                        // Update charts if included
                        if (data.data && (data.data.metrics || data.data.system_info)) {
                            updateChartsWithData(data.data);
                        }
                        // Update reprocess switch to keep it synchronized
                        updateReprocessingCard(data.data.system_info);
                        // Update cleanup card to keep it synchronized
                        updateCleanupCard(data.data.system_info);
                        break;
                    case 'sell_all_list_update':
                        updateSellAllList(data.data);
                        // Reload orders also
                        loadOrders();
                        break;
                    case 'order_status_change':
                        handleOrdersWebSocketMessage(data);
                        break;
                    case 'audit_update':
                        // Optionally refresh audit trail on new events
                        if (currentPage === 1) {
                            loadAuditTrail();
                        }
                        break;
                    case 'metrics_reset':
                        // Handle metrics reset
                        if (data.data) {
                            updateMetrics(data.data);
                        }
                        showAlert('Metrics reset successfully', 'info');
                        break;
                    case 'top_n_tickers_update':
                        updateTopNTickers(data.data);
                        break;
                    default:
                        console.log('Unknown WebSocket message type:', data.type);
                }
            } catch (error) {
                console.error('Error handling WebSocket message:', error);
                console.error('Message data:', data);
            }
        }
        
        // Update connection status indicator
        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionIndicator');
            const text = document.getElementById('connectionText');
            const statusAlert = document.getElementById('connectionStatus');
            
            if (connected) {
                indicator.className = 'status-indicator status-online';
                text.textContent = 'Connected';
                statusAlert.style.display = 'none';
            } else {
                indicator.className = 'status-indicator status-offline';
                text.textContent = 'Disconnected';
                statusAlert.style.display = 'block';
            }
        }
        
        // Initialize charts
        function initializeCharts() {
            // Signals per hour chart
            const signalsCtx = document.getElementById('signalsChart').getContext('2d');
            signalsChart = new Chart(signalsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Signals Received',
                        data: [],
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
            
            // Approval rate chart
            const approvalCtx = document.getElementById('approvalChart').getContext('2d');
            approvalChart = new Chart(approvalCtx, {
                type: 'doughnut',
                data: {
                    labels: ['Approved', 'Rejected'],
                    datasets: [{
                        data: [0, 0],
                        backgroundColor: [
                            'rgba(40, 167, 69, 0.8)',
                            'rgba(220, 53, 69, 0.8)'
                        ],
                        borderColor: [
                            'rgba(40, 167, 69, 1)',
                            'rgba(220, 53, 69, 1)'
                        ],
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    }
                }
            });
        }
        
        
        
        // Load initial data
        async function loadInitialData() {
            try {
                // Load status data
                await loadSystemStatus();
                
                // Load sell all list
                await loadSellAllList();
                
                // Load top-N tickers list
                await loadTopNTickers();
                
                // Load audit trail
                await loadAuditTrail();
                
                // Load cleanup configuration
                await loadCleanupConfig();
                
            } catch (error) {
                console.error('Error loading initial data:', error);
                showAlert('Error loading initial data', 'danger');
            }
        }
        
        // Load system status - UPDATED VERSION 2.0
        async function loadSystemStatus() {
            try {
                const response = await fetch('/admin/system-info');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                
                console.debug('System status data received:', data);
                
                updateMetrics(data.metrics);
                updateSystemStatus(data.system_info);
                updateChartsWithData(data);
                
            } catch (error) {
                console.error('Error loading system status:', error);
                showAlert('Error loading system status: ' + error.message, 'warning');
            }
        }
        
        // Update metrics display - VERSION 3.0 (Fixed maxWorkers undefined error)
        function updateMetrics(metrics) {
            if (!metrics) {
                console.warn('updateMetrics called with no metrics data');
                return;
            }
            
            try {
                // Basic metrics updates
                document.getElementById('signalsReceived').textContent = metrics.signals_received || 0;
                document.getElementById('signalsApproved').textContent = metrics.signals_approved || 0;
                document.getElementById('signalsRejected').textContent = metrics.signals_rejected || 0;
                document.getElementById('signalsForwarded').textContent = metrics.signals_forwarded_success || 0;
                document.getElementById('processingQueueSize').textContent = metrics.processing_queue_size || 0;
                document.getElementById('approvedQueueSize').textContent = metrics.approved_queue_size || 0;
                document.getElementById('processingWorkersActive').textContent = metrics.processing_workers_active || 0;
                document.getElementById('forwardingWorkersActive').textContent = metrics.forwarding_workers_active || 0;
                
                // Update worker progress bars - ensure variables are defined within scope
                const maxForwardingWorkers = 5;  // Define exactly here
                const maxProcessingWorkers = 16; // Define exactly here
                
                // Processing workers progress bar
                const activeProcessingWorkers = parseInt(metrics.processing_workers_active) || 0;
                const processingPercent = Math.min((activeProcessingWorkers / maxProcessingWorkers) * 100, 100);
                const processingProgressBar = document.getElementById('processingWorkerProgress');
                if (processingProgressBar) {
                    processingProgressBar.style.width = `${processingPercent}%`;
                }
                
                // Forwarding workers progress bar
                const activeForwardingWorkers = parseInt(metrics.forwarding_workers_active) || 0;
                const forwardingPercent = Math.min((activeForwardingWorkers / maxForwardingWorkers) * 100, 100);
                const forwardingProgressBar = document.getElementById('forwardingWorkerProgress');
                if (forwardingProgressBar) {
                    forwardingProgressBar.style.width = `${forwardingPercent}%`;
                }
                
                // Update approval chart with real data
                if (typeof approvalChart !== 'undefined' && approvalChart) {
                    const approved = parseInt(metrics.signals_approved) || 0;
                    const rejected = parseInt(metrics.signals_rejected) || 0;
                    const total = approved + rejected;
                    
                    approvalChart.data.datasets[0].data = [approved, rejected];
                    approvalChart.update();
                    
                    // Add data source note
                    const approvalContainer = document.querySelector('#approvalChart');
                    if (approvalContainer && approvalContainer.parentElement) {
                        let approvalNote = approvalContainer.parentElement.querySelector('.approval-data-note');
                        if (!approvalNote) {
                            approvalNote = document.createElement('small');
                            approvalNote.className = 'approval-data-note text-muted d-block mt-2';
                            approvalContainer.parentElement.appendChild(approvalNote);
                        }
                        
                        if (total > 0) {
                            const approvalRate = ((approved / total) * 100).toFixed(1);
                            approvalNote.textContent = `📊 Approval rate: ${approvalRate}% (${approved}/${total})`;
                            approvalNote.className = 'approval-data-note text-success d-block mt-2';
                        } else {
                            approvalNote.textContent = '📊 Waiting for signal data...';
                            approvalNote.className = 'approval-data-note text-muted d-block mt-2';
                        }
                    }
                }
                
                console.debug('Metrics updated successfully:', {
                    received: metrics.signals_received,
                    approved: metrics.signals_approved,
                    rejected: metrics.signals_rejected,
                    processing_workers: activeProcessingWorkers,
                    forwarding_workers: activeForwardingWorkers
                });
                
            } catch (error) {
                console.error('Error in updateMetrics function:', error);
                console.error('Metrics data received:', metrics);
            }
        }
        
        // Update system status
        function updateSystemStatus(systemInfo) {
            if (!systemInfo) return;
            
            // Engine status
            const engineStatus = document.getElementById('engineStatus');
            const enginePaused = systemInfo.finviz_engine_paused || false;
            if (enginePaused) {
                engineStatus.textContent = 'Paused';
                engineStatus.className = 'badge badge-status bg-warning';
            } else {
                engineStatus.textContent = 'Active';
                engineStatus.className = 'badge badge-status bg-success';
            }
            
            // Rate limiter status
            const rateLimiterStatus = document.getElementById('rateLimiterStatus');
            const rlPaused = systemInfo.webhook_rate_limiter_paused || false;
            if (rlPaused) {
                rateLimiterStatus.textContent = 'Paused';
                rateLimiterStatus.className = 'badge badge-status bg-warning';
            } else {
                rateLimiterStatus.textContent = 'Active';
                rateLimiterStatus.className = 'badge badge-status bg-success';
            }
            
            // Ticker count
            const tickerCount = systemInfo.finviz_ticker_count || 0;
            document.getElementById('tickerCount').textContent = tickerCount;
            
            // Uptime
            if (systemInfo.uptime_seconds) {
                const uptime = formatUptime(systemInfo.uptime_seconds);
                document.getElementById('uptime').textContent = uptime;
            }
        }        // Update charts with historical data
        async function updateChartsWithData(data) {
            // Always try to get real historical data from the database
            try {
                console.log('Fetching signals history...');
                const historyResponse = await fetch('/admin/signals-history?hours=24');
                if (!historyResponse.ok) {
                    throw new Error(`HTTP ${historyResponse.status}: ${historyResponse.statusText}`);
                }
                const historyData = await historyResponse.json();
                console.log('History data received:', historyData);
                
                // Always update chart, even with zero data
                if (historyData.data && Array.isArray(historyData.data)) {
                    const labels = historyData.data.map(item => item.hour || item.hour_label || 'N/A');
                    const signalData = historyData.data.map(item => 
                        item.signals_received || item.total_signals || 0
                    );
                    
                    console.log('Chart data - Labels:', labels, 'Data:', signalData);
                    
                    if (signalsChart) {
                        signalsChart.data.labels = labels;
                        signalsChart.data.datasets[0].data = signalData;
                        signalsChart.update();
                        console.log('Chart updated successfully');
                    }
                    
                    // Update data source note
                    updateChartSourceNote(historyData);
                    return; // Success - exit early
                } else {
                    console.warn('No data array in history response');
                    throw new Error('Invalid data format received');
                }
            } catch (error) {
                console.error('Failed to load historical data:', error);
                showAlert('Historical data not available, using fallback', 'warning');
                
                // Generate fallback data if all else fails
                generateFallbackChartData(data);
            }
        }
        
        function updateChartSourceNote(historyData) {
            const chartContainer = document.querySelector('#signalsChart').parentElement;
            let sourceNote = chartContainer.querySelector('.data-source-note');
            if (!sourceNote) {
                sourceNote = document.createElement('small');
                sourceNote.className = 'data-source-note text-muted d-block mt-2';
                chartContainer.appendChild(sourceNote);
            }
            
            const totalSignals = historyData.data ? 
                historyData.data.reduce((sum, item) => sum + (item.signals_received || item.total_signals || 0), 0) : 0;
            
            if (historyData.source === 'database') {
                sourceNote.textContent = `📊 Real data from PostgreSQL (${totalSignals} signals in 24h)`;
                sourceNote.className = 'data-source-note text-success d-block mt-2';
            } else if (historyData.source === 'calculated') {
                sourceNote.textContent = `📈 Estimated data (${totalSignals} estimated signals)`;
                sourceNote.className = 'data-source-note text-warning d-block mt-2';
            } else {
                sourceNote.textContent = `ℹ️ Source: ${historyData.source || 'unknown'} (${totalSignals} signals)`;
                sourceNote.className = 'data-source-note text-info d-block mt-2';
            }
        }
        
        function generateFallbackChartData(data) {
            if (!signalsChart) return;
            
            // Generate hourly labels for the last 24 hours
            const now = new Date();
            const labels = [];
            const signalData = [];
            
            // Get current metrics for reference
            const totalSignals = data?.metrics?.signals_received || 0;
            const hoursOfUptime = data?.system_info?.uptime_seconds ? 
                Math.min(24, data.system_info.uptime_seconds / 3600) : 1;
            
            // Generate basic fallback data
            for (let i = 23; i >= 0; i--) {
                const hour = new Date(now.getTime() - (i * 60 * 60 * 1000));
                labels.push(hour.getHours().toString().padStart(2, '0') + ':00');
                
                if (i >= (24 - hoursOfUptime)) {
                    // System was running during this hour
                    const hourlyAverage = hoursOfUptime > 0 ? totalSignals / hoursOfUptime : 0;
                    signalData.push(Math.max(0, Math.floor(hourlyAverage + (Math.random() - 0.5) * hourlyAverage * 0.3)));
                } else {
                    // System wasn't running - no signals
                    signalData.push(0);
                }
            }
            
            signalsChart.data.labels = labels;
            signalsChart.data.datasets[0].data = signalData;
            signalsChart.update();
            
            // Add fallback note
            const chartContainer = document.querySelector('#signalsChart').parentElement;
            let sourceNote = chartContainer.querySelector('.data-source-note');
            if (!sourceNote) {
                sourceNote = document.createElement('small');
                sourceNote.className = 'data-source-note text-muted d-block mt-2';
                chartContainer.appendChild(sourceNote);
            }
            sourceNote.textContent = '⚠️ Basic fallback data (history unavailable)';
            sourceNote.className = 'data-source-note text-muted d-block mt-2';
        }
        
        // Load sell all list
        async function loadSellAllList() {
            try {
                const response = await fetch('/admin/sell-all-queue');
                const data = await response.json();
                updateSellAllList(data);
            } catch (error) {
                console.error('Error loading sell all list:', error);
            }
        }
        
        // Update sell all list display
        function updateSellAllList(data) {
            const container = document.getElementById('sellAllTickers');
            
            if (!data || !data.tickers || data.tickers.length === 0) {
                container.innerHTML = '<span class="text-muted">No tickers in list</span>';
                return;
            }
            
            const tickersHtml = data.tickers.map(ticker => 
                `<span class="sell-all-ticker">${ticker}</span>`
            ).join('');
            
            container.innerHTML = tickersHtml;
        }
        
        // Load top-N tickers list
        async function loadTopNTickers() {
            try {
                const response = await fetch('/admin/top-n-tickers');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                
                updateTopNTickers(data);
                
            } catch (error) {
                console.error('Error loading top-N tickers:', error);
                showAlert('Error loading Top-N Tickers list: ' + error.message, 'danger');
            }
        }
          // Update top-N tickers display
        function updateTopNTickers(data) {
            const container = document.getElementById('topNTickers');
            const countDisplay = document.getElementById('topNTickerCount');
            const timestampDisplay = document.getElementById('topNTimestamp');
            
            if (!data || !data.tickers || data.tickers.length === 0) {
                container.innerHTML = '<span class="text-muted">No approved tickers</span>';
                countDisplay.textContent = '0';
                timestampDisplay.textContent = '-';
                return;
            }

            const tickersHtml = data.tickers.map(ticker => 
                `<span class="sell-all-ticker clickable-ticker" onclick="addTopNTickerToSellAll('${ticker}')" title="Click to add to Sell All list">${ticker}</span>`
            ).join('');
            
            container.innerHTML = tickersHtml;
            countDisplay.textContent = data.tickers.length;
            
            // Update timestamp - try multiple possible timestamp fields
            const timestampFields = ['last_update', 'timestamp', 'engine_info.last_update'];
            let timestampValue = null;
            
            for (const field of timestampFields) {
                if (field.includes('.')) {
                    // Handle nested properties like engine_info.last_update
                    const parts = field.split('.');
                    let value = data;
                    for (const part of parts) {
                        if (value && value[part] !== undefined) {
                            value = value[part];
                        } else {
                            value = null;
                            break;
                        }
                    }
                    if (value) {
                        timestampValue = value;
                        break;
                    }
                } else {
                    if (data[field]) {
                        timestampValue = data[field];
                        break;
                    }
                }
            }
            
            if (timestampValue) {
                try {
                    // Handle both Unix timestamp (seconds) and ISO strings
                    let date;
                    if (typeof timestampValue === 'number') {
                        // Unix timestamp - might be in seconds or milliseconds
                        date = timestampValue > 1000000000000 ? 
                               new Date(timestampValue) : 
                               new Date(timestampValue * 1000);
                    } else {
                        date = new Date(timestampValue);
                    }
                    
                    if (!isNaN(date.getTime())) {
                        const options = { 
                            year: 'numeric', month: 'numeric', day: 'numeric', 
                            hour: 'numeric', minute: 'numeric', second: 'numeric', 
                            hour12: false 
                        };
                        timestampDisplay.textContent = date.toLocaleString('en-US', options);
                    } else {
                        timestampDisplay.textContent = 'Invalid date';
                    }
                } catch (e) {
                    console.warn('Error parsing timestamp:', timestampValue, e);
                    timestampDisplay.textContent = 'Date error';
                }
            } else {
                timestampDisplay.textContent = 'Now';
            }
        }
        
        // Load audit trail
        async function loadAuditTrail() {
            if (isLoading) return;
            
            isLoading = true;
            const tbody = document.getElementById('auditTableBody');
            const spinner = tbody.querySelector('.loading-spinner');
            
            if (spinner) {
                spinner.style.display = 'inline-block';
            }
            
            try {
                const params = new URLSearchParams();
                
                // Get filter values
                const limit = document.getElementById('limitSelect').value;
                const status = document.getElementById('statusFilter').value;
                const signalType = document.getElementById('signalTypeFilter').value;
                const ticker = document.getElementById('tickerFilter').value;
                const signalId = document.getElementById('signalIdFilter').value;
                const hours = document.getElementById('hourFilter').value;
                
                params.append('limit', limit);
                params.append('offset', (currentPage - 1) * parseInt(limit));
                
                if (status) params.append('status_filter', status);
                if (signalType) params.append('signal_type', signalType);
                if (ticker) params.append('ticker', ticker);
                if (signalId) params.append('signal_id', signalId);
                if (hours) params.append('hours', hours);
                
                const response = await fetch(`/admin/audit-trail?${params}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const data = await response.json();
                
                displayAuditTrail(data);
                updatePagination(data);
                
            } catch (error) {
                console.error('Error loading audit trail:', error);
                tbody.innerHTML = '<tr><td colspan="8" class="text-center text-danger">Error loading audit data: ' + error.message + '</td></tr>';
                showAlert('Error loading audit: ' + error.message, 'danger');
            } finally {
                isLoading = false;
            }
        }
        
        // Display audit trail data
        function displayAuditTrail(data) {
            const tbody = document.getElementById('auditTableBody');
            
            if (!data.events || data.events.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="text-center text-muted">No events found</td></tr>';
                return;
            }
            
            const rows = data.events.map(event => {
                // Handle invalid timestamps more robustly
                let timestamp = 'Invalid date';
                if (event.timestamp) {
                    try {
                        let date;
                        // Handle different timestamp formats
                        if (typeof event.timestamp === 'number') {
                            // Unix timestamp - check if it's in seconds or milliseconds
                            date = event.timestamp > 1000000000000 ? 
                                   new Date(event.timestamp) : 
                                   new Date(event.timestamp * 1000);
                        } else if (typeof event.timestamp === 'string') {
                            // ISO string or other string format
                            // Check if it's ISO format with Z suffix
                            if (event.timestamp.includes('T')) {
                                date = new Date(event.timestamp);
                            } else {
                                // Try parsing as Unix timestamp string
                                const numTimestamp = parseFloat(event.timestamp);
                                if (!isNaN(numTimestamp)) {
                                    date = numTimestamp > 1000000000000 ? 
                                           new Date(numTimestamp) : 
                                           new Date(numTimestamp * 1000);
                                } else {
                                    date = new Date(event.timestamp);
                                }
                            }
                        } else {
                            date = new Date(event.timestamp);
                        }
                        
                        if (date && !isNaN(date.getTime())) {
                            timestamp = date.toLocaleString('en-US', {
                                year: 'numeric', month: '2-digit', day: '2-digit',
                                hour: '2-digit', minute: '2-digit', second: '2-digit',
                                hour12: false
                            });
                        }
                    } catch (e) {
                        console.warn('Invalid timestamp format:', event.timestamp, e);
                        // Try to show the raw timestamp if parsing fails
                        timestamp = String(event.timestamp);
                    }
                }
                
                const statusBadge = getStatusBadge(event.event_type);
                const locationBadge = getLocationBadge(event.location);
                const httpStatus = event.http_status || (event.http_status === 0 ? '0' : '-');
                const details = event.details || '-';
                const workerId = event.worker_id || '-';
                const signalId = event.signal_id ? 
                    event.signal_id : 
                    'N/A';
                const signalTypeBadge = getSignalTypeBadge(event.signal_type || 'buy');
                
                return `
                    <tr>
                        <td>${timestamp}</td>
                        <td><code>${signalId}</code></td>
                        <td><strong>${event.ticker || '-'}</strong></td>
                        <td>${signalTypeBadge}</td>
                        <td>${statusBadge}</td>
                        <td>${locationBadge}</td>
                        <td><small>${workerId}</small></td>
                        <td><small>${details}</small></td>
                        <td>${httpStatus}</td>
                    </tr>
                `;
            }).join('');
            
            tbody.innerHTML = rows;
        }
        
        // Get status badge HTML
        function getStatusBadge(status) {
            const statusColors = {
                'RECEIVED': 'bg-info',
                'APPROVED': 'bg-success',
                'REJECTED': 'bg-warning',
                'FORWARDED_SUCCESS': 'bg-success',
                'FORWARDED_HTTP_ERROR': 'bg-danger',
                'FORWARDED_GENERIC_ERROR': 'bg-danger',
                'ERROR': 'bg-danger',
                'PROCESSING': 'bg-primary',
                'FORWARDING': 'bg-info'
            };
            
            const color = statusColors[status] || 'bg-secondary';
            return `<span class="badge ${color}">${status}</span>`;
        }
        
        // Get location badge HTML
        function getLocationBadge(location) {
            const locationColors = {
                'PROCESSING_QUEUE': 'bg-primary',
                'APPROVED_QUEUE': 'bg-warning',
                'WORKER_PROCESSING': 'bg-info',
                'WORKER_FORWARDING': 'bg-info',
                'COMPLETED': 'bg-success',
                'DISCARDED': 'bg-secondary'
            };
            
            const color = locationColors[location] || 'bg-secondary';
            return `<span class="badge ${color}">${location}</span>`;
        }
        
        // Get signal type badge HTML
        function getSignalTypeBadge(signalType) {
            const typeColors = {
                'buy': 'bg-success',
                'sell': 'bg-warning',
                'manual_sell': 'bg-info',
                'sell_all': 'bg-danger'
            };
            
            const typeDisplayNames = {
                'buy': 'Buy',
                'sell': 'Sell',
                'manual_sell': 'Manual Sell',
                'sell_all': 'Sell All'
            };
            
            const color = typeColors[signalType] || 'bg-secondary';
            const displayName = typeDisplayNames[signalType] || signalType;
            return `<span class="badge ${color}">${displayName}</span>`;
        }
        
        // Update pagination controls
        function updatePagination(data) {
            const resultsInfo = document.getElementById('auditResultsInfo');
            const pageInfo = document.getElementById('pageInfo');
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            
            const limit = parseInt(document.getElementById('limitSelect').value);
            const total = data.total || 0;
            const hasMore = data.has_more || false;
            
            resultsInfo.textContent = `Showing ${data.events?.length || 0} of ${total} events`;
            pageInfo.textContent = `Page ${currentPage}`;
            
            prevBtn.disabled = currentPage === 1;
            nextBtn.disabled = !hasMore;
        }
        
        // Bind event handlers
        function bindEventHandlers() {
            // Control buttons
            document.getElementById('pauseEngineBtn').addEventListener('click', () => sendControlCommand('/admin/engine/pause', 'Engine paused'));
            document.getElementById('resumeEngineBtn').addEventListener('click', () => sendControlCommand('/admin/engine/resume', 'Engine resumed'));
            document.getElementById('refreshEngineBtn').addEventListener('click', () => sendControlCommand('/admin/engine/manual-refresh', 'Ticker update started'));
            document.getElementById('resetMetricsBtn').addEventListener('click', () => sendControlCommand('/admin/metrics/reset', 'Metrics reset'));
            document.getElementById('pauseRateLimiterBtn').addEventListener('click', () => sendControlCommand('/admin/webhook-rate-limiter/pause', 'Rate Limiter paused'));
            document.getElementById('resumeRateLimiterBtn').addEventListener('click', () => sendControlCommand('/admin/webhook-rate-limiter/resume', 'Rate Limiter resumed'));
            
            // Sell all buttons
            document.getElementById('executeSellAllBtn').addEventListener('click', executeSellAll);
            document.getElementById('refreshSellAllBtn').addEventListener('click', loadSellAllList);
            document.getElementById('addTickerBtn').addEventListener('click', addTickerToSellAll);
            document.getElementById('sellIndividualBtn').addEventListener('click', executeIndividualSell);
            
            // Top-N refresh button
            document.getElementById('refreshTopNBtn').addEventListener('click', loadTopNTickers);

            // Reprocessing card controls
            document.getElementById('reprocessingModeSelect').addEventListener('change', handleReprocessingModeChange);
            document.getElementById('applyReprocessingConfigBtn').addEventListener('click', applyReprocessingConfig);
            
            // Cleanup card controls
            document.getElementById('saveCleanupConfigBtn').addEventListener('click', saveCleanupConfig);
            
            // Add focus listeners to the reprocessing container
            const reprocessingContainer = document.getElementById('reprocessingEngineContainer');
            reprocessingContainer.addEventListener('focusin', () => {
                isInteractingWithReprocessing = true;
                console.log('User is interacting with reprocessing controls.');
            });
            
            reprocessingContainer.addEventListener('focusout', (event) => {
                // Use setTimeout to allow for focus to move between elements in the container
                setTimeout(() => {
                    if (!reprocessingContainer.contains(document.activeElement)) {
                        isInteractingWithReprocessing = false;
                        console.log('User has stopped interacting with reprocessing controls. Reloading state.');
                        loadSystemStatus(); // Reload to revert any unsaved changes
                    }
                }, 100);
            });
            
            // Add focus listeners to the cleanup container
            const cleanupContainer = document.getElementById('sellAllCleanupContainer');
            cleanupContainer.addEventListener('focusin', () => {
                isInteractingWithCleanup = true;
                console.log('User is interacting with cleanup controls.');
            });
            
            cleanupContainer.addEventListener('focusout', (event) => {
                // Use setTimeout to allow for focus to move between elements in the container
                setTimeout(() => {
                    if (!cleanupContainer.contains(document.activeElement)) {
                        isInteractingWithCleanup = false;
                        console.log('User has stopped interacting with cleanup controls. Reloading state.');
                        loadSystemStatus(); // Reload to revert any unsaved changes
                    }
                }, 100);
            });
            
            // Manual ticker input - add on Enter key
            document.getElementById('manualTickerInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addTickerToSellAll();
                }
            });
            
            // Individual sell input - sell on Enter key
            document.getElementById('sellIndividualInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    executeIndividualSell();
                }
            });
            
            // Audit trail controls
            document.getElementById('applyFiltersBtn').addEventListener('click', () => {
                currentPage = 1;
                loadAuditTrail();
            });
            document.getElementById('clearFiltersBtn').addEventListener('click', clearFilters);
            document.getElementById('prevPageBtn').addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    loadAuditTrail();
                }
            });
            document.getElementById('nextPageBtn').addEventListener('click', () => {
                currentPage++;
                loadAuditTrail();
            });
            
            // Database Management - CSV export/import
            document.getElementById('downloadCsvBtn').addEventListener('click', downloadDatabaseCsv);
            document.getElementById('selectCsvBtn').addEventListener('click', selectCsvFile);
            document.getElementById('uploadCsvBtn').addEventListener('click', uploadDatabaseCsv);
            document.getElementById('clearDatabaseBtn').addEventListener('click', clearDatabase);
            document.getElementById('csvUploadInput').addEventListener('change', handleCsvFileSelection);
            
            // Orders management event handlers
            document.getElementById('orderStatusFilter').addEventListener('change', (e) => {
                ordersFilters.status = e.target.value;
                loadOrders();
            });
            
            document.getElementById('tickerFilter').addEventListener('input', (e) => {
                ordersFilters.ticker = e.target.value;
                // Debounce to avoid too many requests
                clearTimeout(window.tickerFilterTimeout);
                window.tickerFilterTimeout = setTimeout(loadOrders, 500);
            });
            
            document.getElementById('refreshOrdersBtn').addEventListener('click', loadOrders);
        }

        function handleReprocessingModeChange() {
            const mode = document.getElementById('reprocessingModeSelect').value;
            const windowContainer = document.getElementById('reprocessingWindowContainer');
            if (mode === 'window') {
                windowContainer.style.display = 'block';
            } else {
                windowContainer.style.display = 'none';
            }
        }

        async function applyReprocessingConfig() {
            isInteractingWithReprocessing = false; // Allow updates after applying config
            const mode = document.getElementById('reprocessingModeSelect').value;
            const windowSeconds = document.getElementById('reprocessingWindowInput').value;

            let payload = {
                reprocess_enabled: false,
                reprocess_window_seconds: 0
            };

            if (mode === 'window') {
                payload.reprocess_enabled = true;
                payload.reprocess_window_seconds = parseInt(windowSeconds);
            } else if (mode === 'infinite') {
                payload.reprocess_enabled = true;
                payload.reprocess_window_seconds = 0;
            }

            try {
                let token = localStorage.getItem('admin_token');
                if (!token) {
                    token = prompt('Enter admin token:');
                    if (!token) {
                        showAlert('Token required to update reprocessing config', 'warning');
                        isInteractingWithReprocessing = true; // Re-engage interaction lock
                        return;
                    }
                    localStorage.setItem('admin_token', token);
                }
                payload.token = token;

                const response = await fetch('/finviz/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    showAlert('Reprocessing configuration updated successfully', 'success');
                    loadSystemStatus(); // Refresh system status to reflect changes
                } else if (response.status === 403) {
                    localStorage.removeItem('admin_token');
                    showAlert('Invalid token. Please try again.', 'danger');
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('Error updating reprocessing config:', error);
                showAlert(`Error updating reprocessing config: ${error.message}`, 'danger');
            }
        }

        function updateReprocessingCard(systemInfo) {
            if (!systemInfo || isInteractingWithReprocessing) {
                if(isInteractingWithReprocessing) console.log("Skipping reprocessing card update due to user interaction.");
                return;
            }

            const statusBadge = document.getElementById('reprocessingEngineStatus');
            const modeSelect = document.getElementById('reprocessingModeSelect');
            const windowContainer = document.getElementById('reprocessingWindowContainer');
            const windowInput = document.getElementById('reprocessingWindowInput');

            const reprocessMode = systemInfo.reprocess_mode || 'Disabled';
            const windowSeconds = systemInfo.reprocess_window_seconds;

            if (reprocessMode === 'Disabled') {
                statusBadge.textContent = 'DISABLED';
                statusBadge.className = 'badge bg-secondary fs-6';
                modeSelect.value = 'disabled';
                windowContainer.style.display = 'none';
            } else if (reprocessMode === 'Infinite') {
                statusBadge.textContent = 'ACTIVE (Infinite)';
                statusBadge.className = 'badge bg-info fs-6';
                modeSelect.value = 'infinite';
                windowContainer.style.display = 'none';
            } else { // Time window
                statusBadge.textContent = `ACTIVE (${windowSeconds}s Window)`;
                statusBadge.className = 'badge bg-success fs-6';
                modeSelect.value = 'window';
                windowContainer.style.display = 'block';
                windowInput.value = windowSeconds || 300;
            }
        }
        
        function updateCleanupCard(systemInfo) {
            if (!systemInfo || isInteractingWithCleanup) {
                if(isInteractingWithCleanup) console.log("Skipping cleanup card update due to user interaction.");
                return;
            }

            const statusBadge = document.getElementById('sellAllCleanupStatus');
            const enabledSwitch = document.getElementById('cleanupEnabledSwitch');
            const lifetimeInput = document.getElementById('lifetimeHoursInput');

            const enabled = systemInfo.sell_all_cleanup_enabled !== undefined ? systemInfo.sell_all_cleanup_enabled : true;
            const lifetime = systemInfo.sell_all_cleanup_lifetime_hours !== undefined ? systemInfo.sell_all_cleanup_lifetime_hours : 72;

            if (enabled) {
                statusBadge.textContent = `ACTIVE (${lifetime}h Lifetime)`;
                statusBadge.className = 'badge bg-success fs-6';
            } else {
                statusBadge.textContent = 'DISABLED';
                statusBadge.className = 'badge bg-secondary fs-6';
            }

            if (enabledSwitch) enabledSwitch.checked = enabled;
            if (lifetimeInput) lifetimeInput.value = lifetime;
        }
        
        // Send control command
        async function sendControlCommand(endpoint, successMessage) {
            try {
                // Get admin token if needed
                let token = localStorage.getItem('admin_token');
                if (!token) {
                    token = prompt('Enter admin token:');
                    if (!token) {
                        showAlert('Token required to execute administrative commands', 'warning');
                        return;
                    }
                    localStorage.setItem('admin_token', token);
                }

                const response = await fetch(endpoint, { 
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ token: token })
                });
                
                if (response.ok) {
                    showAlert(successMessage, 'success');
                    // Refresh status after a short delay
                    setTimeout(loadSystemStatus, 1000);
                } else if (response.status === 403) {
                    // Clear invalid token
                    localStorage.removeItem('admin_token');
                    showAlert('Invalid token. Please try again.', 'danger');
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }
            } catch (error) {
                console.error(`Error sending command to ${endpoint}:`, error);
                showAlert(`Error executing command: ${error.message}`, 'danger');
            }
        }
        
        // Execute sell all
        async function executeSellAll() {
            if (!confirm('Are you sure you want to execute SELL ALL? This action will sell all positions in the list.')) {
                return;
            }
            
            try {
                // Get admin token
                let token = localStorage.getItem('admin_token');
                if (!token) {
                    token = prompt('Enter admin token:');
                    if (!token) {
                        showAlert('Admin token required to execute SELL ALL', 'warning');
                        return;
                    }
                    localStorage.setItem('admin_token', token);
                }

                const response = await fetch('/admin/order/sell-all', { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: token })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showAlert(`Sell All executed successfully! ${data.signals_sent || data.processed_tickers || 'N/A'} signals sent.`, 'success');
                    loadSellAllList();
                } else if (response.status === 403) {
                    localStorage.removeItem('admin_token');
                    showAlert('Invalid token. Please try again.', 'danger');
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('Error executing sell all:', error);
                showAlert(`Error executing Sell All: ${error.message}`, 'danger');
            }
        }

        // Add ticker to Sell All list
        async function addTickerToSellAll() {
            const input = document.getElementById('manualTickerInput');
            const ticker = input.value.trim().toUpperCase();
            
            if (!ticker) {
                showAlert('Please enter a valid ticker', 'warning');
                return;
            }
            
            try {
                // Get admin token
                let token = localStorage.getItem('admin_token');
                if (!token) {
                    token = prompt('Enter admin token:');
                    if (!token) {
                        showAlert('Admin token required to add ticker', 'warning');
                        return;
                    }
                    localStorage.setItem('admin_token', token);
                }

                const response = await fetch('/admin/sell-all-queue', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        token: token,
                        ticker: ticker 
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showAlert(`Ticker ${ticker} added to Sell All list`, 'success');
                    input.value = '';  // Clear input
                    loadSellAllList();  // Refresh list
                } else if (response.status === 403) {
                    localStorage.removeItem('admin_token');
                    showAlert('Invalid token. Please try again.', 'danger');
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('Error adding ticker to sell all:', error);
                showAlert(`Error adding ticker: ${error.message}`, 'danger');
            }
        }

        // Execute individual sell order
        async function executeIndividualSell() {
            const input = document.getElementById('sellIndividualInput');
            const ticker = input.value.trim().toUpperCase();
            
            if (!ticker) {
                showAlert('Please enter a valid ticker', 'warning');
                return;
            }
            
            if (!confirm(`Are you sure you want to create an individual sell order for ${ticker}?`)) {
                return;
            }
            
            try {
                // Get admin token
                let token = localStorage.getItem('admin_token');
                if (!token) {
                    token = prompt('Enter admin token:');
                    if (!token) {
                        showAlert('Admin token required to execute individual sell', 'warning');
                        return;
                    }
                    localStorage.setItem('admin_token', token);
                }

                const response = await fetch('/admin/order/sell-individual', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        token: token,
                        ticker: ticker 
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showAlert(`Individual sell order created for ${ticker}`, 'success');
                    input.value = '';  // Clear input
                    loadAuditTrail();  // Refresh audit trail to show new signal
                } else if (response.status === 403) {
                    localStorage.removeItem('admin_token');
                    showAlert('Invalid token. Please try again.', 'danger');
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('Error executing individual sell:', error);
                showAlert(`Error executing individual sell: ${error.message}`, 'danger');
            }
        }

        // Add ticker from Top-N list to Sell All (called when clicking on ticker)
        async function addTopNTickerToSellAll(ticker) {
            if (!confirm(`Add ${ticker} to Sell All list?`)) {
                return;
            }
            
            try {
                // Get admin token
                let token = localStorage.getItem('admin_token');
                if (!token) {
                    token = prompt('Enter admin token:');
                    if (!token) {
                        showAlert('Admin token required to add ticker', 'warning');
                        return;
                    }
                    localStorage.setItem('admin_token', token);
                }

                const response = await fetch('/admin/sell-all-queue', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        token: token,
                        ticker: ticker 
                    })
                });
                
                if (response.ok) {
                    showAlert(`Ticker ${ticker} added to Sell All list`, 'success');
                    loadSellAllList();  // Refresh sell all list
                } else if (response.status === 403) {
                    localStorage.removeItem('admin_token');
                    showAlert('Invalid token. Please try again.', 'danger');
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('Error adding Top-N ticker to sell all:', error);
                showAlert(`Error adding ticker: ${error.message}`, 'danger');
            }
        }
        
        // Clear filters
        function clearFilters() {
            document.getElementById('statusFilter').value = '';
            document.getElementById('signalTypeFilter').value = '';
            document.getElementById('tickerFilter').value = '';
            document.getElementById('signalIdFilter').value = '';
            document.getElementById('hourFilter').value = '';
            currentPage = 1;
            loadAuditTrail();
        }
        
        // Database Management - CSV Export/Import Functions
        async function downloadDatabaseCsv() {
            try {
                showAlert('Preparing database export...', 'info');
                
                const response = await fetch('/admin/export-csv', {
                    method: 'GET',
                    headers: {
                        'Accept': 'text/csv'
                    }
                });
                
                if (!response.ok) {
                    if (response.status === 204) {
                        showAlert('No data available for export', 'warning');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const csvContent = await response.text();
                const blob = new Blob([csvContent], { type: 'text/csv' });
                
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `urban_chainsaw_database_export_${new Date().toISOString().split('T')[0]}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                showAlert('Database export completed successfully!', 'success');
                
            } catch (error) {
                console.error('Error downloading CSV:', error);
                showAlert(`Error downloading database export: ${error.message}`, 'danger');
            }
        }
        
        function selectCsvFile() {
            document.getElementById('csvUploadInput').click();
        }
        
        function handleCsvFileSelection() {
            const fileInput = document.getElementById('csvUploadInput');
            const uploadBtn = document.getElementById('uploadCsvBtn');
            const fileNameDisplay = document.getElementById('csvFileName');
            
            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                fileNameDisplay.textContent = file.name;
                uploadBtn.disabled = false;
                uploadBtn.title = `Upload ${file.name}`;
            } else {
                fileNameDisplay.textContent = '';
                uploadBtn.disabled = true;
                uploadBtn.title = 'Select a CSV file first';
            }
        }
        
        async function uploadDatabaseCsv() {
            const fileInput = document.getElementById('csvUploadInput');
            const file = fileInput.files[0];
            
            if (!file) {
                showAlert('Please select a CSV file to upload', 'warning');
                return;
            }
            
            if (!file.name.toLowerCase().endsWith('.csv')) {
                showAlert('Please select a valid CSV file', 'warning');
                return;
            }
            
            if (!confirm('Are you sure you want to import this CSV file? This will merge the data with existing database records. Existing records with the same signal_id will be updated.')) {
                return;
            }
            
            try {
                // Get admin token
                let token = localStorage.getItem('admin_token');
                if (!token) {
                    token = prompt('Enter admin token:');
                    if (!token) {
                        showAlert('Admin token required for database import', 'warning');
                        return;
                    }
                    localStorage.setItem('admin_token', token);
                }
                
                showAlert('Uploading CSV file...', 'info');
                
                const formData = new FormData();
                formData.append('file', file);
                formData.append('token', token);
                
                const response = await fetch('/admin/import-csv', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const summary = data.summary || {};
                    
                    let summaryText = 'CSV import completed!\n';
                    summaryText += `• Signals created: ${summary.signals_created || 0}\n`;
                    summaryText += `• Signals updated: ${summary.signals_updated || 0}\n`;
                    summaryText += `• Events created: ${summary.events_created || 0}\n`;
                    summaryText += `• Events updated: ${summary.events_updated || 0}`;
                    
                    if (summary.rows_skipped && summary.rows_skipped > 0) {
                        summaryText += `\n• Rows skipped: ${summary.rows_skipped}`;
                    }
                    
                    if (summary.errors && summary.errors.length > 0) {
                        summaryText += `\n• Errors: ${summary.errors.length}`;
                        if (summary.errors.length > 0) {
                            summaryText += '\n\nFirst few errors:';
                            summary.errors.slice(0, 3).forEach(error => {
                                summaryText += `\n  - ${error}`;
                            });
                            if (summary.errors.length > 3) {
                                summaryText += `\n  ... and ${summary.errors.length - 3} more errors`;
                            }
                        }
                    }
                    
                    const alertType = (summary.errors && summary.errors.length > 0) ? 'warning' : 'success';
                    showAlert(summaryText.replace(/\n/g, '<br>'), alertType);
                    
                    // Clear the file input and reset UI
                    fileInput.value = '';
                    handleCsvFileSelection();
                    
                    // Refresh audit trail to show updated data
                    loadAuditTrail();
                    
                    // Refresh system status
                    loadSystemStatus();
                    
                } else if (response.status === 403) {
                    localStorage.removeItem('admin_token');
                    showAlert('Invalid token. Please try again.', 'danger');
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }
                
            } catch (error) {
                console.error('Error uploading CSV:', error);
                showAlert(`Error importing CSV file: ${error.message}`, 'danger');
            }
        }
        
        async function clearDatabase() {
            if (!confirm('⚠️ Are you ABSOLUTELY SURE you want to PERMANENTLY DELETE ALL database records?\n\nThis action will:\n• Delete ALL signals and events\n• Remove ALL audit trail history\n• Cannot be undone\n\nType "DELETE ALL" in the next prompt to confirm.')) {
                return;
            }
            
            const confirmText = prompt('To proceed with deletion, type exactly: DELETE ALL');
            if (confirmText !== 'DELETE ALL') {
                showAlert('Database clear cancelled - confirmation text did not match', 'info');
                return;
            }
            
            try {
                // Get admin token
                let token = localStorage.getItem('admin_token');
                if (!token) {
                    token = prompt('Enter admin token:');
                    if (!token) {
                        showAlert('Admin token required to clear database', 'warning');
                        return;
                    }
                    localStorage.setItem('admin_token', token);
                }
                
                showAlert('Clearing database... This may take a moment.', 'warning');
                
                const response = await fetch('/admin/clear-database', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: token })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    showAlert(`Database cleared successfully! Deleted ${data.deleted_signals || 0} signals and ${data.deleted_events || 0} events.`, 'success');
                    
                    // Refresh all data displays
                    loadAuditTrail();
                    loadSystemStatus();
                    
                } else if (response.status === 403) {
                    localStorage.removeItem('admin_token');
                    showAlert('Invalid token. Please try again.', 'danger');
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `HTTP ${response.status}`);
                }
                
            } catch (error) {
                console.error('Error clearing database:', error);
                showAlert(`Error clearing database: ${error.message}`, 'danger');
            }
        }
        
        // Show alert
        function showAlert(message, type) {
            const container = document.getElementById('alertContainer');
            const alertId = 'alert-' + Date.now();
            
            const alertHtml = `
                <div id="${alertId}" class="alert alert-${type} alert-dismissible fade show" role="alert">
                    ${message}
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                </div>
            `;
            
            container.insertAdjacentHTML('beforeend', alertHtml);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                const alert = document.getElementById(alertId);
                if (alert) {
                    const bsAlert = new bootstrap.Alert(alert);
                    bsAlert.close();
                }
            }, 5000);
        }
        
        // Format uptime
        function formatUptime(seconds) {
            const days = Math.floor(seconds / 86400);
            const hours = Math.floor((seconds % 86400) / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            
            if (days > 0) {
                return `${days}d ${hours}h ${minutes}m`;
            } else if (hours > 0) {
                return `${hours}h ${minutes}m`;
            } else {
                return `${minutes}m`;
            }
        }
        
        // Configuration Panel Functions
        function initializeConfigPanel() {
            // Bind configuration modal events (only if elements exist)
            const openConfigBtn = document.getElementById('openConfigBtn');
            if (openConfigBtn) {
                openConfigBtn.addEventListener('click', openConfigModal);
            }
            
            const setTokenBtn = document.getElementById('setTokenBtn');
            if (setTokenBtn) {
                setTokenBtn.addEventListener('click', setAdminToken);
            }
            
            // Guard against non-existent elements to prevent JS errors
            const loadCurrentConfigBtn = document.getElementById('loadCurrentConfigBtn');
            if (loadCurrentConfigBtn) {
                loadCurrentConfigBtn.addEventListener('click', loadCurrentConfig);
            }
            
            const updateWebhookBtn = document.getElementById('updateWebhookBtn');
            if (updateWebhookBtn) {
                updateWebhookBtn.addEventListener('click', updateWebhookConfig);
            }
            
            const updateFinvizBtn = document.getElementById('updateFinvizBtn');
            if (updateFinvizBtn) {
                updateFinvizBtn.addEventListener('click', updateFinvizConfig);
            }
            
            const updateRateLimiterBtn = document.getElementById('updateRateLimiterBtn');
            if (updateRateLimiterBtn) {
                updateRateLimiterBtn.addEventListener('click', updateRateLimiterConfig);
            }
            
            const saveTokenBtn = document.getElementById('saveTokenBtn');
            if (saveTokenBtn) {
                saveTokenBtn.addEventListener('click', saveAdminToken);
            }
            
            const clearTokenBtn = document.getElementById('clearTokenBtn');
            if (clearTokenBtn) {
                clearTokenBtn.addEventListener('click', clearAdminToken);
            }
            
            const toggleTokenVisibility = document.getElementById('toggleTokenVisibility');
            if (toggleTokenVisibility) {
                toggleTokenVisibility.addEventListener('click', toggleTokenVisibilityHandler);
            }
            
            // Load saved token if available
            loadSavedToken();
        }
        
        function openConfigModal() {
            const configModal = document.getElementById('configModal');
            if (!configModal) {
                console.warn('Configuration modal not found in DOM');
                showAlert('Configuration modal not available', 'warning');
                return;
            }
            
            const modal = new bootstrap.Modal(configModal);
            modal.show();
            loadCurrentConfig();
        }
        
        function setAdminToken() {
            const token = prompt('Enter admin token:');
            if (token) {
                localStorage.setItem('admin_token', token);
                const adminTokenElement = document.getElementById('adminToken');
                if (adminTokenElement) {
                    adminTokenElement.value = token;
                }
                showAlert('Token saved successfully!', 'success');
            }
        }
        
        async function loadCurrentConfig() {
            try {
                // Load webhook config
                const webhookResponse = await fetch('/admin/webhook/config');
                if (webhookResponse.ok) {
                    const webhookData = await webhookResponse.json();
                    const webhookUrlElement = document.getElementById('webhookUrl');
                    const webhookTimeoutElement = document.getElementById('webhookTimeout');
                    if (webhookUrlElement) webhookUrlElement.value = webhookData.webhook_url || '';
                    if (webhookTimeoutElement) webhookTimeoutElement.value = webhookData.timeout || 5;
                }
                
                // Load finviz config
                const finvizResponse = await fetch('/admin/finviz/config');
                if (finvizResponse.ok) {
                    const finvizData = await finvizResponse.json();
                    const finvizUrlElement = document.getElementById('finvizUrl');
                    const topNElement = document.getElementById('topN');
                    const refreshIntervalElement = document.getElementById('refreshInterval');
                    if (finvizUrlElement) finvizUrlElement.value = finvizData.finviz_url || '';
                    if (topNElement) topNElement.value = finvizData.top_n || 15;
                    if (refreshIntervalElement) refreshIntervalElement.value = finvizData.refresh_interval_sec || 10;
                }
                
                // Load rate limiter config (from system status)
                const statusResponse = await fetch('/admin/system-info');
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    const rlInfo = statusData.system_info?.webhook_rate_limiter || {};
                    const maxReqElement = document.getElementById('maxReqPerMin');
                    const rateLimitingElement = document.getElementById('rateLimitingEnabled');
                    if (maxReqElement) maxReqElement.value = rlInfo.max_req_per_min || 60;
                    if (rateLimitingElement) rateLimitingElement.checked = !rlInfo.paused;
                }
                
            } catch (error) {
                console.error('Error loading current config:', error);
                showAlert('Error loading current configurations', 'warning');
            }
        }
        
        async function updateWebhookConfig() {
            const token = getAdminToken();
            if (!token) return;
            
            const webhookUrlElement = document.getElementById('webhookUrl');
            const timeoutElement = document.getElementById('webhookTimeout');
            
            if (!webhookUrlElement || !timeoutElement) {
                showAlert('Webhook configuration fields not found', 'warning');
                return;
            }
            
            const webhookUrl = webhookUrlElement.value;
            const timeout = timeoutElement.value;
            
            if (!webhookUrl) {
                showAlert('Webhook URL is required', 'warning');
                return;
            }
            
            try {
                const response = await fetch('/admin/webhook/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        token: token,
                        webhook_url: webhookUrl,
                        timeout: parseInt(timeout)
                    })
                });
                
                if (response.ok) {
                    showAlert('Webhook configuration updated successfully!', 'success');
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('Error updating webhook config:', error);
                showAlert('Error updating webhook configuration: ' + error.message, 'danger');
            }
        }
        
        async function updateFinvizConfig() {
            const token = getAdminToken();
            if (!token) return;
            
            const finvizUrlElement = document.getElementById('finvizUrl');
            const topNElement = document.getElementById('topN');
            const refreshIntervalElement = document.getElementById('refreshInterval');
            
            if (!finvizUrlElement || !topNElement || !refreshIntervalElement) {
                showAlert('Finviz configuration fields not found', 'warning');
                return;
            }
            
            const finvizUrl = finvizUrlElement.value;
            const topN = topNElement.value;
            const refreshInterval = refreshIntervalElement.value;
            
            if (!finvizUrl) {
                showAlert('Finviz URL is required', 'warning');
                return;
            }
            
            try {
                const response = await fetch('/finviz/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        token: token,
                        finviz_url: finvizUrl,
                        top_n: parseInt(topN),
                        refresh_interval_sec: parseInt(refreshInterval)
                    })
                });
                
                if (response.ok) {
                    showAlert('Finviz configuration updated successfully!', 'success');
                    // Update system status to reflect changes
                    setTimeout(() => {
                        loadSystemStatus();
                    }, 1000);
                } else {
                    const errorData = await response.json().catch(() => ({ detail: `HTTP ${response.status}` }));
                    throw new Error(errorData.detail);
                }
            } catch (error) {
                console.error('Error updating finviz config:', error);
                showAlert('Error updating Finviz configuration: ' + error.message, 'danger');
            }
        }

        async function updateReprocessConfig() {
            const token = getAdminToken();
            if (!token) return;

            const reprocessEnabled = document.getElementById('reprocessEnabledSwitch').checked;
            const reprocessWindowSeconds = document.getElementById('reprocessWindowInput').value;

            // We can reuse the finviz config endpoint as it's part of the same engine settings
            try {
                // First, fetch current finviz config to avoid overwriting other settings
                const currentConfigResponse = await fetch('/admin/finviz/config');
                if (!currentConfigResponse.ok) {
                    showAlert('Could not load current Finviz config to update reprocess settings.', 'danger');
                    return;
                }
                const currentConfig = await currentConfigResponse.json();

                const response = await fetch('/finviz/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        token: token,
                        finviz_url: currentConfig.finviz_url, // Keep current URL
                        top_n: currentConfig.top_n, // Keep current Top-N
                        refresh_interval_sec: currentConfig.refresh_interval_sec, // Keep current refresh
                        reprocess_enabled: reprocessEnabled,
                        reprocess_window_seconds: parseInt(reprocessWindowSeconds)
                    })
                });

                if (response.ok) {
                    showAlert('Reprocess configuration updated successfully!', 'success');
                    // Update system status to reflect changes
                    setTimeout(() => {
                        loadSystemStatus();
                    }, 1000);
                } else {
                    const errorData = await response.json().catch(() => ({ detail: `HTTP ${response.status}` }));
                    throw new Error(errorData.detail);
                }
            } catch (error) {
                console.error('Error updating reprocess config:', error);
                showAlert('Error updating Reprocess configuration: ' + error.message, 'danger');
            }
        }
        
        async function updateRateLimiterConfig() {
            const token = getAdminToken();
            if (!token) return;
            
            const maxReqElement = document.getElementById('maxReqPerMin');
            const enabledElement = document.getElementById('rateLimitingEnabled');
            
            if (!maxReqElement || !enabledElement) {
                showAlert('Rate limiter configuration fields not found', 'warning');
                return;
            }
            
            const maxReqPerMin = maxReqElement.value;
            const enabled = enabledElement.checked;
            
            try {
                const response = await fetch('/admin/webhook-rate-limiter/update', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        token: token,
                        max_req_per_min: parseInt(maxReqPerMin),
                        enabled: enabled
                    })
                });
                
                if (response.ok) {
                    showAlert('Rate Limiter configuration updated successfully!', 'success');
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                console.error('Error updating rate limiter config:', error);
                showAlert('Error updating Rate Limiter configuration: ' + error.message, 'danger');
            }
        }
        
        function getAdminToken() {
            let token = localStorage.getItem('admin_token');
            if (!token) {
                token = prompt('Enter admin token:');
                if (token) {
                    localStorage.setItem('admin_token', token);
                } else {
                    showAlert('Token required for changes', 'warning');
                    return null;
                }
            }
            return token;
        }
        
        function saveAdminToken() {
            const tokenElement = document.getElementById('adminToken');
            if (!tokenElement) {
                showAlert('Token field not found', 'warning');
                return;
            }
            
            const token = tokenElement.value;
            if (token) {
                localStorage.setItem('admin_token', token);
                showAlert('Token saved successfully!', 'success');
            } else {
                showAlert('Enter a valid token', 'warning');
            }
        }
        
        function clearAdminToken() {
            localStorage.removeItem('admin_token');
            const tokenElement = document.getElementById('adminToken');
            if (tokenElement) {
                tokenElement.value = '';
            }
            showAlert('Token removed', 'info');
        }
        
        function toggleTokenVisibilityHandler() {
            const tokenInput = document.getElementById('adminToken');
            const toggleBtn = document.getElementById('toggleTokenVisibility');
            
            if (!tokenInput || !toggleBtn) {
                return;
            }
            
            const icon = toggleBtn.querySelector('i');
            
            if (tokenInput.type === 'password') {
                tokenInput.type = 'text';
                if (icon) {
                    icon.className = 'bi bi-eye-slash';
                }
            } else {
                tokenInput.type = 'password';
                if (icon) {
                    icon.className = 'bi bi-eye';
                }
            }
        }
        
        function loadSavedToken() {
            const savedToken = localStorage.getItem('admin_token');
            if (savedToken) {
                const adminTokenElement = document.getElementById('adminToken');
                if (adminTokenElement) {
                    adminTokenElement.value = savedToken;
                }
            }
        }
        
        // Initialize configuration panel when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            initializeConfigPanel();

            // Bind Sell All List Cleanup buttons
            const clearBtn = document.getElementById('clearSellAllBtn');
            if (clearBtn) {
                clearBtn.addEventListener('click', clearSellAllList);
            } else {
                console.error("clearSellAllBtn not found");
            }

            const saveCleanupBtn = document.getElementById('saveCleanupConfigBtn');
            if (saveCleanupBtn) {
                saveCleanupBtn.addEventListener('click', saveCleanupConfig);
            } else {
                console.error("saveCleanupConfigBtn not found");
            }
        });

        // --- Sell All List Cleanup Functions ---
        async function clearSellAllList() {
            if (!confirm('Are you sure you want to clear the entire Sell All list? This action cannot be undone.')) {
                return;
            }
            const token = getAdminToken(); // Use existing getAdminToken function
            if (!token) return;

            try {
                const response = await fetch('/admin/sell-all-queue/clear', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: token })
                });
                const data = await response.json(); // Assuming server sends JSON response
                if (response.ok) {
                    showAlert(data.message || 'Sell All list cleared successfully.', 'success');
                    // UI update will be handled by WebSocket message 'sell_all_list_update'
                } else {
                    throw new Error(data.detail || 'Failed to clear list');
                }
            } catch (error) {
                showAlert(`Error clearing list: ${error.message}`, 'danger');
            }
        }

        async function loadCleanupConfig() {
            try {
                const response = await fetch('/admin/sell-all/config');
                if (!response.ok) throw new Error('Failed to fetch cleanup config');
                const data = await response.json();

                const enabledSwitch = document.getElementById('cleanupEnabledSwitch');
                const lifetimeInput = document.getElementById('lifetimeHoursInput');

                if(enabledSwitch) {
                    enabledSwitch.checked = data.enabled !== undefined ? data.enabled : true;
                } else {
                    console.error("cleanupEnabledSwitch not found during load");
                }

                if(lifetimeInput) {
                    lifetimeInput.value = data.lifetime_hours !== undefined ? data.lifetime_hours : 72;
                } else {
                    console.error("lifetimeHoursInput not found during load");
                }

            } catch (error) {
                console.error('Error loading cleanup config:', error);
                showAlert('Could not load Sell All cleanup settings.', 'warning');
                
                // Set defaults if loading failed
                const enabledSwitch = document.getElementById('cleanupEnabledSwitch');
                const lifetimeInput = document.getElementById('lifetimeHoursInput');
                
                if(enabledSwitch) enabledSwitch.checked = true;
                if(lifetimeInput) lifetimeInput.value = 72;
            }
        }

        async function saveCleanupConfig() {
            isInteractingWithCleanup = false; // Allow updates after applying config
            
            const token = getAdminToken();
            if (!token) {
                isInteractingWithCleanup = true; // Re-engage interaction lock
                return;
            }

            const enabledSwitch = document.getElementById('cleanupEnabledSwitch');
            const lifetimeInput = document.getElementById('lifetimeHoursInput');

            if (!enabledSwitch || !lifetimeInput) {
                showAlert('Cleanup config UI elements not found. Cannot save.', 'danger');
                console.error("Cleanup config UI elements not found for saving.");
                isInteractingWithCleanup = true; // Re-engage interaction lock
                return;
            }

            const enabled = enabledSwitch.checked;
            const lifetime_hours_str = lifetimeInput.value;
            const lifetime_hours = parseInt(lifetime_hours_str);

            if (isNaN(lifetime_hours) || lifetime_hours <= 0) {
                showAlert('Ticker lifetime must be a positive number of hours.', 'warning');
                isInteractingWithCleanup = true; // Re-engage interaction lock
                return;
            }

            try {
                const response = await fetch('/admin/sell-all/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        token: token,
                        enabled: enabled,
                        lifetime_hours: lifetime_hours
                    })
                });

                if (response.status === 204) {
                    showAlert('Cleanup settings saved successfully!', 'success');
                    loadSystemStatus(); // Refresh system status to reflect changes
                } else if (response.ok) {
                     showAlert('Cleanup settings saved successfully! (Status: ' + response.status + ')', 'success');
                     loadSystemStatus(); // Refresh system status to reflect changes
                } else {
                    // Try to parse error detail, otherwise show generic error
                    const errorData = await response.json().catch(() => ({ detail: `Failed to save settings (HTTP ${response.status})` }));
                    throw new Error(errorData.detail);
                }
            } catch (error) {
                console.error('Error saving cleanup config:', error);
                showAlert(`Error saving settings: ${error.message}`, 'danger');
                isInteractingWithCleanup = true; // Re-engage interaction lock
            }
        }
        // --- End Sell All List Cleanup Functions ---

    </script>

    <!-- Configuration Modal -->
    <div class="modal fade" id="configModal" tabindex="-1" aria-labelledby="configModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="configModalLabel">
                        <i class="bi bi-gear"></i> System Configuration
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <!-- Token Management Section -->
                    <div class="mb-4">
                        <h6 class="text-primary mb-3">
                            <i class="bi bi-key"></i> Admin Token Management
                        </h6>
                        <div class="row">
                            <div class="col-md-8">
                                <div class="input-group">
                                    <input type="password" class="form-control" id="adminToken" placeholder="Enter admin token">
                                    <button class="btn btn-outline-secondary" type="button" id="toggleTokenVisibility">
                                        <i class="bi bi-eye"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="btn-group w-100">
                                    <button type="button" class="btn btn-primary" id="saveTokenBtn">
                                        <i class="bi bi-save"></i> Save
                                    </button>
                                    <button type="button" class="btn btn-outline-danger" id="clearTokenBtn">
                                        <i class="bi bi-trash"></i> Clear
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Load Current Config Button -->
                    <div class="mb-4">
                        <button type="button" class="btn btn-info w-100" id="loadCurrentConfigBtn">
                            <i class="bi bi-download"></i> Load Current Configuration
                        </button>
                    </div>

                    <!-- Webhook Configuration -->
                    <div class="mb-4">
                        <h6 class="text-primary mb-3">
                            <i class="bi bi-webhook"></i> Webhook Configuration
                        </h6>
                        <div class="row mb-3">
                            <div class="col-md-8">
                                <label for="webhookUrl" class="form-label">Webhook URL</label>
                                <input type="url" class="form-control" id="webhookUrl" placeholder="https://example.com/webhook">
                            </div>
                            <div class="col-md-4">
                                <label for="webhookTimeout" class="form-label">Timeout (seconds)</label>
                                <input type="number" class="form-control" id="webhookTimeout" min="1" max="60" value="5">
                            </div>
                        </div>
                        <button type="button" class="btn btn-success" id="updateWebhookBtn">
                            <i class="bi bi-check-circle"></i> Update Webhook Config
                        </button>
                    </div>

                    <!-- Finviz Configuration -->
                    <div class="mb-4">
                        <h6 class="text-primary mb-3">
                            <i class="bi bi-bar-chart"></i> Finviz Configuration
                        </h6>
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="finvizUrl" class="form-label">Finviz URL</label>
                                <input type="url" class="form-control" id="finvizUrl" placeholder="https://finviz.com/screener.ashx?...">
                            </div>
                            <div class="col-md-3">
                                <label for="topN" class="form-label">Top N</label>
                                <input type="number" class="form-control" id="topN" min="1" max="100" value="15">
                            </div>
                            <div class="col-md-3">
                                <label for="refreshInterval" class="form-label">Refresh Interval (sec)</label>
                                <input type="number" class="form-control" id="refreshInterval" min="5" max="3600" value="10">
                            </div>
                        </div>
                        <button type="button" class="btn btn-success" id="updateFinvizBtn">
                            <i class="bi bi-check-circle"></i> Update Finviz Config
                        </button>
                    </div>

                    <!-- Rate Limiter Configuration -->
                    <div class="mb-4">
                        <h6 class="text-primary mb-3">
                            <i class="bi bi-speedometer2"></i> Rate Limiter Configuration
                        </h6>
                        <div class="row mb-3">
                            <div class="col-md-6">
                                <label for="maxReqPerMin" class="form-label">Max Requests per Minute</label>
                                <input type="number" class="form-control" id="maxReqPerMin" min="1" max="1000" value="60">
                            </div>
                            <div class="col-md-6">
                                <div class="form-check form-switch mt-4">
                                    <input class="form-check-input" type="checkbox" role="switch" id="rateLimitingEnabled" checked>
                                    <label class="form-check-label" for="rateLimitingEnabled">
                                        Enable Rate Limiting
                                    </label>
                                </div>
                            </div>
                        </div>
                        <button type="button" class="btn btn-success" id="updateRateLimiterBtn">
                            <i class="bi bi-check-circle"></i> Update Rate Limiter Config
                        </button>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ===================================================================
        // ORDERS MANAGEMENT FUNCTIONS
        // ===================================================================

        // Function to format date/time
        function formatDateTime(dateString) {
            if (!dateString) return '—';
            const date = new Date(dateString);
            return date.toLocaleString('en-US', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }

        // Load orders initially
        async function loadOrders() {
            try {
                const params = new URLSearchParams();
                if (ordersFilters.status !== 'all') params.append('status', ordersFilters.status);
                if (ordersFilters.ticker) params.append('ticker', ordersFilters.ticker);
                
                const response = await fetch(`/admin/orders?${params}`);
                const data = await response.json();
                
                ordersData = data.orders;
                updateOrdersTable();
                updateOrdersStats();
            } catch (error) {
                console.error('Error loading orders:', error);
                showAlert(`Error loading orders: ${error.message}`, 'danger');
            }
        }

        // Update orders table
        function updateOrdersTable() {
            const tbody = document.getElementById('ordersTableBody');
            
            if (ordersData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">No orders found</td></tr>';
                return;
            }
            
            tbody.innerHTML = ordersData.map(order => {
                const statusBadge = getStatusBadge(order.status);
                const actionButton = getActionButton(order);
                
                return `
                    <tr id="order-${order.id}" class="order-row" data-status="${order.status}">
                        <td><strong>${order.ticker}</strong></td>
                        <td>${statusBadge}</td>
                        <td>${formatDateTime(order.opened_at)}</td>
                        <td>${order.closed_at ? formatDateTime(order.closed_at) : '—'}</td>
                        <td>${order.duration}</td>
                        <td>$${order.entry_price.toFixed(2)}</td>
                        <td>${actionButton}</td>
                    </tr>
                `;
            }).join('');
        }

        // Status badge with colors
        function getStatusBadge(status) {
            const badges = {
                'open': '<span class="badge bg-success">Open</span>',
                'closing': '<span class="badge bg-warning">Closing</span>',
                'closed': '<span class="badge bg-secondary">Closed</span>'
            };
            return badges[status] || `<span class="badge bg-info">${status}</span>`;
        }

        // Action button based on status
        function getActionButton(order) {
            if (order.status === 'open') {
                return `<button class="btn btn-sm btn-outline-danger" onclick="closeOrderManually(${order.id})">
                            <i class="bi bi-x-circle"></i> Close
                        </button>`;
            }
            return '—';
        }

        // Close order manually
        async function closeOrderManually(positionId) {
            if (!confirm('Are you sure you want to close this order manually?')) return;
            
            try {
                const token = getAdminToken();
                if (!token) return;
                
                const response = await fetch(`/admin/orders/${positionId}/close`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token })
                });
                
                if (response.ok) {
                    showAlert('Order closed successfully', 'success');
                    loadOrders(); // Reload list
                } else {
                    const data = await response.json();
                    throw new Error(data.detail || `HTTP ${response.status}`);
                }
            } catch (error) {
                showAlert(`Error closing order: ${error.message}`, 'danger');
            }
        }

        // Update statistics
        async function updateOrdersStats() {
            try {
                const response = await fetch('/admin/orders/stats');
                const data = await response.json();
                
                document.getElementById('openOrdersCount').textContent = data.stats.open || 0;
                document.getElementById('closingOrdersCount').textContent = data.stats.closing || 0;
                document.getElementById('closedTodayCount').textContent = data.stats.closed_today || 0;
                
            } catch (error) {
                console.error('Error updating stats:', error);
            }
        }

        // WebSocket message updates for orders
        function handleOrdersWebSocketMessage(data) {
            if (data.type === 'order_status_change') {
                const { position_id, new_status } = data.data;
                
                // Update specific row in table
                const row = document.getElementById(`order-${position_id}`);
                if (row) {
                    row.setAttribute('data-status', new_status);
                    // Animate change
                    row.classList.add('table-warning');
                    setTimeout(() => {
                        row.classList.remove('table-warning');
                        loadOrders(); // Reload for complete data
                    }, 1000);
                }
                
                // Show notification
                showAlert(`Order ${position_id} changed to: ${new_status}`, 'info');
            }
            
            if (data.type === 'sell_all_list_update') {
                loadSellAllList(); // Existing function
                loadOrders(); // Reload orders also
            }
        }

    </script>

</body>
</html>
